#define min(x,y) (x<y->x:y)
#define max(x,y) (x>y->x:y)
chan wait=[10] of {int,mtype};
mtype={
        getBrightnessValue, getOperationalState, 
        setBrightnessValue, ccOK, 
        ccFAIL, setDesiredBrightnessValue, 
        setMotionValue, shutdownES, 
        st_PowerOff, st_NormalBehavior, 
        st_FaultyState, st_Init, 
        changeDimmerValue, getManualMode, 
        setWarningLevel, getMotionValue, 
        getDesiredBrightnessValue, correctFault, 
        faultOccurred, dimmerOK, 
        setDimmerValue
};
typedef Timer_T {
        bool timerwait;
        }
Timer_T Timer_V;

typedef BrightnessSensor_T {
        bool timerwait;
        int brightnessValue;
        int correctedBrightnessValue;
        bool operationalState;

        }
BrightnessSensor_T BrightnessSensor_V;

chan BrightnessSensor_q=[5] of {mtype};
chan BrightnessSensor_C=[0] of {bit};
chan BrightnessSensor_setBrightnessValue_p1=[5] of {int};

typedef ComputingComponent_T {
        bool timerwait;
        bool automaticMode;
        int brightnessValue;
        int computedDimmerValue;
        int desiredBrightnessValue;
        bool initialized;
        bool manualMode;
        bool motionValue;

        }
ComputingComponent_T ComputingComponent_V;

chan ComputingComponent_q=[5] of {mtype};
chan ComputingComponent_C=[0] of {bit};
chan ComputingComponent_setBrightnessValue_p1=[5] of {int};
chan ComputingComponent_setDesiredBrightnessValue_p1=[5] of {int};
chan ComputingComponent_setMotionValue_p1=[5] of {bool};
chan Initialize_C=[0] of {bit};
chan Initialize_start=[0] of {bit};
chan NormalBehavior_C=[0] of {bit};
chan NormalBehavior_start=[0] of {bit};
chan Automatic_C=[0] of {bit};
chan Automatic_start=[0] of {bit};
chan Manual_C=[0] of {bit};
chan Manual_start=[0] of {bit};

typedef Corrector_T {
        bool timerwait;


        }
Corrector_T Corrector_V;

chan Corrector_q=[5] of {mtype};
chan Corrector_C=[0] of {bit};

typedef Detector_T {
        bool timerwait;


        }
Detector_T Detector_V;



typedef Dimmer_T {
        bool timerwait;
        int deltaDimmerValue;
        int dimmerValue;
        bool operationalState;
        int tempDimmerValue;

        }
Dimmer_T Dimmer_V;

chan Dimmer_q=[5] of {mtype};
chan Dimmer_C=[0] of {bit};
chan Dimmer_changeDimmerValue_p1=[5] of {int};

typedef Environment_T {
        bool timerwait;
        int brightnessValue;
        int dimmerValue;
        bool motionValue;
        int totalBrightnessValue;

        }
Environment_T Environment_V;

chan Environment_q=[5] of {mtype};
chan Environment_C=[0] of {bit};
chan Environment_setDimmerValue_p1=[5] of {int};

typedef GlobalFaultHandler_T {
        bool timerwait;


        }
GlobalFaultHandler_T GlobalFaultHandler_V;

chan GlobalFaultHandler_q=[5] of {mtype};
chan GlobalFaultHandler_C=[0] of {bit};

typedef LocalFaultHandler_T {
        bool timerwait;


        }
LocalFaultHandler_T LocalFaultHandler_V;

chan LocalFaultHandler_q=[5] of {mtype};
chan LocalFaultHandler_C=[0] of {bit};

typedef MotionSensor_T {
        bool timerwait;
        bool motionValue;
        bool operationalState;

        }
MotionSensor_T MotionSensor_V;

chan MotionSensor_q=[5] of {mtype};
chan MotionSensor_C=[0] of {bit};
chan MotionSensor_setMotionValue_p1=[5] of {bool};

typedef UserInterface_T {
        bool timerwait;
        int desiredBrightnessValue;
        bool manualMode;
        short warningLevel;

        }
UserInterface_T UserInterface_V;

chan UserInterface_q=[5] of {mtype};
chan UserInterface_C=[0] of {bit};
chan UserInterface_setWarningLevel_p1=[5] of {short};

        bool fault;

active proctype BrightnessSensor()
{
atomic{
mtype m;

/*Init state*/
        goto  Idle; skip;};
/* State BrValueRequested */
BrValueRequested:     atomic{skip; printf("in state BrightnessSensor.BrValueRequested\n");
        }

        BrValueRequested_G:
        if
        :: atomic{1 -> 
           Environment_q!getBrightnessValue;
           printf("Transition to BrightnessSensor.WaitingForEnvironment (^Environment.getBrightnessValue)");goto WaitingForEnvironment; skip;}
        fi;
/* State DetermineOS */
DetermineOS:     atomic{skip; printf("in state BrightnessSensor.DetermineOS\n");
        }

        DetermineOS_G:
        if
        :: atomic{1 -> 
           BrightnessSensor_V.operationalState=1;
           ComputingComponent_q!ccOK;
           printf("Transition to BrightnessSensor.Idle (/operationalState:=1^ComputingComponent.ccOK)");goto Idle; skip;}
        :: atomic{1 -> 
           BrightnessSensor_V.operationalState=0;
           ComputingComponent_q!ccFAIL;
           printf("Transition to BrightnessSensor.Idle (/operationalState:=0^ComputingComponent.ccFAIL)");goto Idle; skip;}
        fi;
/* State Idle */
Idle:         atomic{skip; printf("in state BrightnessSensor.Idle\n");
        }

        Idle_G:
        if
        :: atomic{BrightnessSensor_q?getOperationalState -> 
           printf("Transition to BrightnessSensor.DetermineOS (evt:getOperationalState())");goto DetermineOS; skip;}
        :: atomic{BrightnessSensor_q?getBrightnessValue -> 
           printf("Transition to BrightnessSensor.BrValueRequested (evt:getBrightnessValue())");goto BrValueRequested; skip;}
        fi;
/* State ValueChecked */
ValueChecked:     atomic{skip; printf("in state BrightnessSensor.ValueChecked\n");
        }

        ValueChecked_G:
        if
        :: atomic{1 -> 
           ComputingComponent_setBrightnessValue_p1!BrightnessSensor_V.brightnessValue; ComputingComponent_q!setBrightnessValue;
           printf("Transition to BrightnessSensor.Idle (^ComputingComponent.setBrightnessValue(brightnessValue))");goto Idle; skip;}
        fi;
/* State ValueReceived */
ValueReceived:     atomic{skip; printf("in state BrightnessSensor.ValueReceived\n");
        }

        ValueReceived_G:
        if
           :: atomic{BrightnessSensor_V.brightnessValue<0 ->
              BrightnessSensor_V.correctedBrightnessValue=0;
              printf("Transition to BrightnessSensor.ValueChecked ([brightnessValue<0]/correctedBrightnessValue:=0)");goto ValueChecked; skip;}
           :: atomic{BrightnessSensor_V.brightnessValue>=0 && BrightnessSensor_V.brightnessValue<=1000 ->
              BrightnessSensor_V.correctedBrightnessValue=BrightnessSensor_V.brightnessValue;
              printf("Transition to BrightnessSensor.ValueChecked ([brightnessValue >=0 & brightnessValue<=1000]/correctedBrightnessValue:=brightnessValue)");goto ValueChecked; skip;}
           :: atomic{BrightnessSensor_V.brightnessValue>1000 ->
              BrightnessSensor_V.correctedBrightnessValue=1000;
              printf("Transition to BrightnessSensor.ValueChecked ([brightnessValue>1000]/correctedBrightnessValue:=1000)");goto ValueChecked; skip;}
        fi;
/* State WaitingForEnvironment */
WaitingForEnvironment:     atomic{skip; printf("in state BrightnessSensor.WaitingForEnvironment\n");
        }

        WaitingForEnvironment_G:
        if
        :: atomic{BrightnessSensor_q?setBrightnessValue -> 
                   BrightnessSensor_setBrightnessValue_p1?BrightnessSensor_V.brightnessValue
                   -> 
           printf("Transition to BrightnessSensor.ValueReceived (evt:setBrightnessValue(brightnessValue))");goto ValueReceived; skip;}
        fi;
exit:      skip
}
active proctype ComputingComponent()
{
atomic{
mtype m;
int Initialize_pid, NormalBehavior_pid;

/*Init state*/
        goto  InitState; skip;};
/* State InitState */
InitState:    atomic{skip; printf("in state ComputingComponent.InitState\n");
        }

        InitState_G:
        if
        :: atomic{ComputingComponent_q?shutdownES -> 
           printf("Transition to ComputingComponent.PowerOff (evt:shutdownES())");goto PowerOff; skip;}
        :: atomic{1 -> 
           printf("Transition to ComputingComponent.Initialize");goto to_Initialize; skip;}
        fi;
/* Link to composite state Initialize */
to_Initialize:  atomic{skip; Initialize_start!1;}
        atomic{Initialize_C?1; wait??Initialize_pid,m;}
        if
        :: atomic{m == st_PowerOff -> goto PowerOff; skip;};
        :: atomic{m == st_NormalBehavior -> goto to_NormalBehavior; skip;};
        fi;
/* Link to composite state NormalBehavior */
to_NormalBehavior:  atomic{skip; NormalBehavior_start!1;}
        atomic{NormalBehavior_C?1; wait??NormalBehavior_pid,m;}
        if
        :: atomic{m == st_PowerOff -> goto PowerOff; skip;};
        fi;
/* State PowerOff */
PowerOff:     atomic{skip; printf("in state ComputingComponent.PowerOff\n");
        }

        PowerOff_G:
        if
        :: atomic{ComputingComponent_q?setDesiredBrightnessValue -> 
                   ComputingComponent_setDesiredBrightnessValue_p1?ComputingComponent_V.desiredBrightnessValue
                   -> 
           printf("Transition to ComputingComponent.PowerOff (evt:setDesiredBrightnessValue(desiredBrightnessValue))");goto PowerOff; skip;}
        :: atomic{ComputingComponent_q?setBrightnessValue -> 
                   ComputingComponent_setBrightnessValue_p1?ComputingComponent_V.brightnessValue
                   -> 
           printf("Transition to ComputingComponent.PowerOff (evt:setBrightnessValue(brightnessValue))");goto PowerOff; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           printf("Transition to ComputingComponent.PowerOff (evt:shutdownES())");goto PowerOff; skip;}
        :: atomic{ComputingComponent_q?ccFAIL -> 
           printf("Transition to ComputingComponent.PowerOff (evt:ccFAIL())");goto PowerOff; skip;}
        :: atomic{ComputingComponent_q?ccOK -> 
           printf("Transition to ComputingComponent.PowerOff (evt:ccOK())");goto PowerOff; skip;}
        fi;
exit:      skip
}
active proctype Initialize(mtype state)
{atomic{
mtype m;
int Initialize_pid;
goto exit;}

startCState:  atomic{
/*Init state*/
        goto  Idle; skip;};
/* State FaultyState */
FaultyState:     atomic{skip; printf("in state ComputingComponent.FaultyState\n");
        }

        FaultyState_G:
        if
        :: atomic{1 -> 
           fault=1;
           printf("Transition to ComputingComponent.FaultyStateReached (/fault:=1)");goto FaultyStateReached; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES())");goto exit; skip;}
        :: atomic{ComputingComponent_q?ccFAIL -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:ccFAIL())");goto exit; skip;}
        fi;
/* State FaultyStateReached */
FaultyStateReached:     atomic{skip; printf("in state ComputingComponent.FaultyStateReached\n");
        }

        FaultyStateReached_G:
        if
        :: atomic{ComputingComponent_q?shutdownES -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES())");goto exit; skip;}
        :: atomic{ComputingComponent_q?ccFAIL -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:ccFAIL())");goto exit; skip;}
        fi;
/* State Idle */
Idle:         atomic{skip; printf("in state ComputingComponent.Idle\n");
        }

        Idle_G:
        if
        :: atomic{1 -> 
           printf("Transition to ComputingComponent.FaultyState");goto FaultyState; skip;}
        :: atomic{1 -> 
           Dimmer_q!getOperationalState;
           printf("Transition to ComputingComponent.State1 (^Dimmer.getOperationalState)");goto State1; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES())");goto exit; skip;}
        :: atomic{ComputingComponent_q?ccFAIL -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:ccFAIL())");goto exit; skip;}
        fi;
/* State State1 */
State1:       atomic{skip; printf("in state ComputingComponent.State1\n");
        }

        State1_G:
        if
        :: atomic{ComputingComponent_q?ccOK -> 
           printf("Transition to ComputingComponent.FaultyState (evt:ccOK())");goto FaultyState; skip;}
        :: atomic{ComputingComponent_q?ccOK -> 
           printf("Transition to ComputingComponent.State2 (evt:ccOK())");goto State2; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES())");goto exit; skip;}
        :: atomic{ComputingComponent_q?ccFAIL -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:ccFAIL())");goto exit; skip;}
        fi;
/* State State2 */
State2:       atomic{skip; printf("in state ComputingComponent.State2\n");
        }

        State2_G:
        if
        :: atomic{1 -> 
           printf("Transition to ComputingComponent.FaultyState");goto FaultyState; skip;}
        :: atomic{1 -> 
           BrightnessSensor_q!getOperationalState;
           printf("Transition to ComputingComponent.State3 (^BrightnessSensor.getOperationalState)");goto State3; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES())");goto exit; skip;}
        :: atomic{ComputingComponent_q?ccFAIL -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:ccFAIL())");goto exit; skip;}
        fi;
/* State State3 */
State3:       atomic{skip; printf("in state ComputingComponent.State3\n");
        }

        State3_G:
        if
        :: atomic{ComputingComponent_q?ccOK -> 
           printf("Transition to ComputingComponent.FaultyState (evt:ccOK())");goto FaultyState; skip;}
        :: atomic{ComputingComponent_q?ccOK -> 
           printf("Transition to ComputingComponent.State4 (evt:ccOK())");goto State4; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES())");goto exit; skip;}
        :: atomic{ComputingComponent_q?ccFAIL -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:ccFAIL())");goto exit; skip;}
        fi;
/* State State4 */
State4:       atomic{skip; printf("in state ComputingComponent.State4\n");
        }

        State4_G:
        if
        :: atomic{1 -> 
           printf("Transition to ComputingComponent.FaultyState");goto FaultyState; skip;}
        :: atomic{1 -> 
           MotionSensor_q!getOperationalState;
           printf("Transition to ComputingComponent.State5 (^MotionSensor.getOperationalState)");goto State5; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES())");goto exit; skip;}
        :: atomic{ComputingComponent_q?ccFAIL -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:ccFAIL())");goto exit; skip;}
        fi;
/* State State5 */
State5:       atomic{skip; printf("in state ComputingComponent.State5\n");
        }

        State5_G:
        if
        :: atomic{ComputingComponent_q?ccOK -> 
           printf("Transition to ComputingComponent.FaultyState (evt:ccOK())");goto FaultyState; skip;}
        :: atomic{ComputingComponent_q?ccOK -> 
           ComputingComponent_V.initialized=1;
           wait!_pid,st_NormalBehavior; Initialize_C!1; printf("Transition to ComputingComponent.NormalBehavior (evt:ccOK()/initialized:=1)");goto exit; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES())");goto exit; skip;}
        :: atomic{ComputingComponent_q?ccFAIL -> 
           wait!_pid,st_PowerOff; Initialize_C!1; printf("Transition to ComputingComponent.PowerOff (evt:ccFAIL())");goto exit; skip;}
        fi;
exit:             Initialize_start?1->goto startCState;

}
active proctype NormalBehavior(mtype state)
{atomic{
mtype m;
int Automatic_pid, NormalBehavior_pid, Manual_pid;
goto exit;}

startCState:  atomic{
/*Init state*/
        goto  Init; skip;};
/* Link to composite state Automatic */
to_Automatic:  atomic{skip; Automatic_start!1;}
        atomic{Automatic_C?1;wait??Automatic_pid,m;}
        if
        :: atomic{m == st_FaultyState -> goto FaultyState; skip;};
        :: atomic{m == st_Init -> goto Init; skip;};
        :: atomic{m == st_PowerOff -> wait!_pid,st_PowerOff; ; goto exit; skip;};

        fi;
/* State EnterAuto */
EnterAuto:    atomic{skip; printf("in state ComputingComponent.EnterAuto\n");
        }

        EnterAuto_G:
        if
        :: atomic{1 -> 
           printf("Transition to ComputingComponent.OpStatusAutoSet");goto OpStatusAutoSet; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; NormalBehavior_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State EnterManual */
EnterManual:     atomic{skip; printf("in state ComputingComponent.EnterManual\n");
        }

        EnterManual_G:
        if
        :: atomic{1 -> 
           printf("Transition to ComputingComponent.OpStatusManualSet");goto OpStatusManualSet; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; NormalBehavior_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State FaultyState */
FaultyState:     atomic{skip; printf("in state ComputingComponent.FaultyState\n");
        }

        FaultyState_G:
        if
        :: atomic{1 -> 
           fault=1;
           printf("Transition to ComputingComponent.FaultyStateReached (/fault:=1)");goto FaultyStateReached; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; NormalBehavior_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State FaultyStateReached */
FaultyStateReached:     atomic{skip; printf("in state ComputingComponent.FaultyStateReached\n");
        }

        FaultyStateReached_G:
        if
        :: atomic{ComputingComponent_q?setBrightnessValue -> 
                   ComputingComponent_setBrightnessValue_p1?ComputingComponent_V.brightnessValue
                   -> 
           printf("Transition to ComputingComponent.FaultyStateReached (evt:setBrightnessValue(brightnessValue))");goto FaultyStateReached; skip;}
        :: atomic{ComputingComponent_q?setDesiredBrightnessValue -> 
                   ComputingComponent_setDesiredBrightnessValue_p1?ComputingComponent_V.desiredBrightnessValue
                   -> 
           printf("Transition to ComputingComponent.FaultyStateReached (evt:setDesiredBrightnessValue(desiredBrightnessValue))");goto FaultyStateReached; skip;}
        :: atomic{ComputingComponent_q?ccFAIL -> 
           printf("Transition to ComputingComponent.FaultyStateReached (evt:ccFAIL())");goto FaultyStateReached; skip;}
        :: atomic{ComputingComponent_q?ccOK -> 
           printf("Transition to ComputingComponent.FaultyStateReached (evt:ccOK())");goto FaultyStateReached; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; NormalBehavior_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State Init */
Init:         atomic{skip; printf("in state ComputingComponent.Init\n");
        }

        Init_G:
        if
        :: atomic{1 -> 
           printf("Transition to ComputingComponent.FaultyState");goto FaultyState; skip;}
        :: atomic{1 -> 
           UserInterface_q!getManualMode;
           printf("Transition to ComputingComponent.ManualModeCheck (^UserInterface.getManualMode)");goto ManualModeCheck; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; NormalBehavior_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* Link to composite state Manual */
to_Manual: atomic{skip; Manual_start!1;}
        atomic{Manual_C?1;wait??Manual_pid,m;}
        if
        :: atomic{m == st_FaultyState -> goto FaultyState; skip;};
        :: atomic{m == st_Init -> goto Init; skip;};
        :: atomic{m == st_PowerOff -> wait!_pid,st_PowerOff; ; goto exit; skip;};

        fi;
/* State ManualModeCheck */
ManualModeCheck:     atomic{skip; printf("in state ComputingComponent.ManualModeCheck\n");
        }

        ManualModeCheck_G:
        if
        :: atomic{ComputingComponent_q?ccOK -> 
           printf("Transition to ComputingComponent.EnterManual (evt:ccOK())");goto EnterManual; skip;}
        :: atomic{ComputingComponent_q?ccFAIL -> 
           printf("Transition to ComputingComponent.EnterAuto (evt:ccFAIL())");goto EnterAuto; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; NormalBehavior_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State OpStatusAutoSet */
OpStatusAutoSet:     atomic{skip; printf("in state ComputingComponent.OpStatusAutoSet\n");
        }

        OpStatusAutoSet_G:
        if
        :: atomic{1 -> 
           printf("Transition to ComputingComponent.Automatic");goto to_Automatic; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; NormalBehavior_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State OpStatusManualSet */
OpStatusManualSet:     atomic{skip; printf("in state ComputingComponent.OpStatusManualSet\n");
        }

        OpStatusManualSet_G:
        if
        :: atomic{1 -> 
           printf("Transition to ComputingComponent.Manual");goto to_Manual; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; NormalBehavior_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
exit:             NormalBehavior_start?1->goto startCState;

}
active proctype Automatic(mtype state)
{atomic{
mtype m;
int NormalBehavior_pid;
goto exit;}

startCState:  atomic{
/*Init state*/
/*Initial actions / messages */
        ComputingComponent_V.automaticMode=1;
        ComputingComponent_V.manualMode=0;
        UserInterface_setWarningLevel_p1!1; UserInterface_q!setWarningLevel;
        goto  Idle; skip;};
/* State ActualValueRequested */
ActualValueRequested:     atomic{skip; printf("in state ComputingComponent.ActualValueRequested\n");
        }

        ActualValueRequested_G:
        if
        :: atomic{ComputingComponent_q?setBrightnessValue -> 
                   ComputingComponent_setBrightnessValue_p1?ComputingComponent_V.brightnessValue
                   -> 
           printf("Transition to ComputingComponent.BrightnessValueReceived (evt:setBrightnessValue(brightnessValue))");goto BrightnessValueReceived; skip;}
        :: atomic{ComputingComponent_q?setBrightnessValue -> 
                   ComputingComponent_setBrightnessValue_p1?ComputingComponent_V.brightnessValue
                   -> 
           wait!_pid,st_FaultyState; Automatic_C!1; printf("Transition to ComputingComponent.FaultyState (evt:setBrightnessValue(brightnessValue))");goto exit; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; Automatic_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State BrightnessValueReceived */
BrightnessValueReceived:     atomic{skip; printf("in state ComputingComponent.BrightnessValueReceived\n");
        }

        BrightnessValueReceived_G:
        if
        :: atomic{1 -> 
           ComputingComponent_V.computedDimmerValue=ComputingComponent_V.desiredBrightnessValue-ComputingComponent_V.brightnessValue;
           printf("Transition to ComputingComponent.CorrectionValueCalculated (/computedDimmerValue:=desiredBrightnessValue-brightnessValue)");goto CorrectionValueCalculated; skip;}
        :: atomic{1 -> 
           wait!_pid,st_FaultyState; Automatic_C!1; printf("Transition to ComputingComponent.FaultyState");goto exit; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; Automatic_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State CorrectionValueCalculated */
CorrectionValueCalculated:     atomic{skip; printf("in state ComputingComponent.CorrectionValueCalculated\n");
        }

        CorrectionValueCalculated_G:
        if
        :: atomic{1 -> 
           Dimmer_changeDimmerValue_p1!ComputingComponent_V.computedDimmerValue; Dimmer_q!changeDimmerValue;
           printf("Transition to ComputingComponent.CorrectionValueSumbitted (^Dimmer.changeDimmerValue(computedDimmerValue))");goto CorrectionValueSumbitted; skip;}
        :: atomic{1 -> 
           wait!_pid,st_FaultyState; Automatic_C!1; printf("Transition to ComputingComponent.FaultyState");goto exit; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; Automatic_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State CorrectionValueSumbitted */
CorrectionValueSumbitted:     atomic{skip; printf("in state ComputingComponent.CorrectionValueSumbitted\n");
        }

        CorrectionValueSumbitted_G:
        if
        :: atomic{ComputingComponent_q?ccOK -> 
           wait!_pid,st_FaultyState; Automatic_C!1; printf("Transition to ComputingComponent.FaultyState (evt:ccOK())");goto exit; skip;}
        :: atomic{ComputingComponent_q?ccOK -> 
           wait!_pid,st_Init; Automatic_C!1; printf("Transition to ComputingComponent.Init (evt:ccOK())");goto exit; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; Automatic_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State DesiredValueReceived */
DesiredValueReceived:     atomic{skip; printf("in state ComputingComponent.DesiredValueReceived\n");
        }

        DesiredValueReceived_G:
        if
        :: atomic{1 -> 
           BrightnessSensor_q!getBrightnessValue;
           printf("Transition to ComputingComponent.ActualValueRequested (^BrightnessSensor.getBrightnessValue)");goto ActualValueRequested; skip;}
        :: atomic{1 -> 
           wait!_pid,st_FaultyState; Automatic_C!1; printf("Transition to ComputingComponent.FaultyState");goto exit; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; Automatic_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State DesiredValueRequested */
DesiredValueRequested:     atomic{skip; printf("in state ComputingComponent.DesiredValueRequested\n");
        }

        DesiredValueRequested_G:
        if
        :: atomic{ComputingComponent_q?setDesiredBrightnessValue -> 
                   ComputingComponent_setDesiredBrightnessValue_p1?ComputingComponent_V.desiredBrightnessValue
                   -> 
           printf("Transition to ComputingComponent.DesiredValueReceived (evt:setDesiredBrightnessValue(desiredBrightnessValue))");goto DesiredValueReceived; skip;}
        :: atomic{ComputingComponent_q?setDesiredBrightnessValue -> 
                   ComputingComponent_setDesiredBrightnessValue_p1?ComputingComponent_V.desiredBrightnessValue
                   -> 
           wait!_pid,st_FaultyState; Automatic_C!1; printf("Transition to ComputingComponent.FaultyState (evt:setDesiredBrightnessValue(desiredBrightnessValue))");goto exit; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; Automatic_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State Idle */
Idle:         atomic{skip; printf("in state ComputingComponent.Idle\n");
        }

        Idle_G:
        if
        :: atomic{ComputingComponent_q?ccOK -> 
           MotionSensor_q!getMotionValue;
           printf("Transition to ComputingComponent.checkPresence (evt:ccOK()^MotionSensor.getMotionValue)");goto checkPresence; skip;}
        :: atomic{1 -> 
           wait!_pid,st_FaultyState; Automatic_C!1; printf("Transition to ComputingComponent.FaultyState");goto exit; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; Automatic_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State MotionValueReeived */
MotionValueReeived:     atomic{skip; printf("in state ComputingComponent.MotionValueReeived\n");
        }

        MotionValueReeived_G:
        if
           :: atomic{ComputingComponent_V.motionValue==1 ->
              UserInterface_q!getDesiredBrightnessValue;
              printf("Transition to ComputingComponent.DesiredValueRequested ([motionValue=1]^UserInterface.getDesiredBrightnessValue)");goto DesiredValueRequested; skip;}
           :: atomic{ComputingComponent_V.motionValue==0 ->
              wait!_pid,st_Init; Automatic_C!1; printf("Transition to ComputingComponent.Init ([motionValue=0])");goto exit; skip;}
        :: atomic{1 -> 
           wait!_pid,st_FaultyState; Automatic_C!1; printf("Transition to ComputingComponent.FaultyState");goto exit; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; Automatic_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State checkPresence */
checkPresence:     atomic{skip; printf("in state ComputingComponent.checkPresence\n");
        }

        checkPresence_G:
        if
        :: atomic{ComputingComponent_q?setMotionValue -> 
                   ComputingComponent_setMotionValue_p1?ComputingComponent_V.motionValue
                   -> 
           printf("Transition to ComputingComponent.MotionValueReeived (evt:setMotionValue(motionValue))");goto MotionValueReeived; skip;}
        :: atomic{ComputingComponent_q?setMotionValue -> 
                   ComputingComponent_setMotionValue_p1?ComputingComponent_V.motionValue
                   -> 
           wait!_pid,st_FaultyState; Automatic_C!1; printf("Transition to ComputingComponent.FaultyState (evt:setMotionValue(motionValue))");goto exit; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; Automatic_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
exit:             Automatic_start?1->goto startCState;

}
active proctype Manual(mtype state)
{atomic{
mtype m;
int NormalBehavior_pid;
goto exit;}

startCState:  atomic{
/*Init state*/
/*Initial actions / messages */
        ComputingComponent_V.manualMode=1;
        ComputingComponent_V.automaticMode=0;
        UserInterface_setWarningLevel_p1!2; UserInterface_q!setWarningLevel;
        goto  Idle; skip;};
/* State DimmerValueSet */
DimmerValueSet:     atomic{skip; printf("in state ComputingComponent.DimmerValueSet\n");
        }

        DimmerValueSet_G:
        if
        :: atomic{ComputingComponent_q?ccOK -> 
           printf("Transition to ComputingComponent.Done (evt:ccOK())");goto Done; skip;}
        :: atomic{ComputingComponent_q?ccOK -> 
           wait!_pid,st_FaultyState; Manual_C!1; printf("Transition to ComputingComponent.FaultyState (evt:ccOK())");goto exit; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; Manual_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State Done */
Done:         atomic{skip; printf("in state ComputingComponent.Done\n");
        }

        Done_G:
        if
        :: atomic{1 -> 
           wait!_pid,st_FaultyState; Manual_C!1; printf("Transition to ComputingComponent.FaultyState");goto exit; skip;}
        :: atomic{1 -> 
           wait!_pid,st_Init; Manual_C!1; printf("Transition to ComputingComponent.Init");goto exit; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; Manual_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
/* State Idle */
Idle:         atomic{skip; printf("in state ComputingComponent.Idle\n");
        }

        Idle_G:
        if
        :: atomic{ComputingComponent_q?ccOK -> 
           Dimmer_changeDimmerValue_p1!1000; Dimmer_q!changeDimmerValue;
           printf("Transition to ComputingComponent.DimmerValueSet (evt:ccOK()^Dimmer.changeDimmerValue(1000))");goto DimmerValueSet; skip;}
        :: atomic{1 -> 
           wait!_pid,st_FaultyState; Manual_C!1; printf("Transition to ComputingComponent.FaultyState");goto exit; skip;}
        :: atomic{ComputingComponent_q?shutdownES -> 
           Dimmer_changeDimmerValue_p1!-1000; Dimmer_q!changeDimmerValue;
           wait!_pid,st_PowerOff; Manual_C!1; printf("Transition to ComputingComponent.PowerOff (evt:shutdownES()^Dimmer.changeDimmerValue(-1000))");goto exit; skip;}
        fi;
exit:             Manual_start?1->goto startCState;

}
active proctype Corrector()
{
atomic{
mtype m;

/*Init state*/
        goto  NoFault; skip;};
/* State CorrectionInitiated */
CorrectionInitiated:     atomic{skip; printf("in state Corrector.CorrectionInitiated\n");
        }
        if
        :: skip -> false
        fi;
/* State Fault */
Fault:        atomic{skip; printf("in state Corrector.Fault\n");
        }

        Fault_G:
        if
        :: atomic{1 -> 
           ComputingComponent_q!shutdownES;
           printf("Transition to Corrector.CorrectionInitiated (^ComputingComponent.shutdownES)");goto CorrectionInitiated; skip;}
        fi;
/* State NoFault */
NoFault:      atomic{skip; printf("in state Corrector.NoFault\n");
        }

        NoFault_G:
        if
        :: atomic{Corrector_q?correctFault -> 
           printf("Transition to Corrector.Fault (evt:correctFault())");goto Fault; skip;}
        fi;
exit:      skip
}
active proctype Detector()
{
atomic{
mtype m;

/*Init state*/
        goto  NoFaultOccurred; skip;};
/* State FaultHasOccurred */
FaultHasOccurred:     atomic{skip; printf("in state Detector.FaultHasOccurred\n");
        }

        FaultHasOccurred_G:
        if
        :: atomic{1 -> 
           LocalFaultHandler_q!faultOccurred;
           printf("Transition to Detector.FaultReported (^LocalFaultHandler.faultOccurred)");goto FaultReported; skip;}
        fi;
/* State FaultReported */
FaultReported:     atomic{skip; printf("in state Detector.FaultReported\n");
        }
        if
        :: skip -> false
        fi;
/* State NoFaultOccurred */
NoFaultOccurred:     atomic{skip; printf("in state Detector.NoFaultOccurred\n");
        }

        NoFaultOccurred_G:
        if
           :: atomic{fault==1 ->
              printf("Transition to Detector.FaultHasOccurred ([fault=1])");goto FaultHasOccurred; skip;}
        fi;
exit:      skip
}
active proctype Dimmer()
{
atomic{
mtype m;

/*Init state*/
        goto  Idle; skip;};
/* State DetermineOS */
DetermineOS:     atomic{skip; printf("in state Dimmer.DetermineOS\n");
        }

        DetermineOS_G:
        if
        :: atomic{1 -> 
           Dimmer_V.operationalState=1;
           ComputingComponent_q!ccOK;
           printf("Transition to Dimmer.Idle (/operationalState:=1^ComputingComponent.ccOK)");goto Idle; skip;}
        :: atomic{1 -> 
           Dimmer_V.operationalState=0;
           ComputingComponent_q!ccFAIL;
           printf("Transition to Dimmer.Idle (/operationalState:=0^ComputingComponent.ccFAIL)");goto Idle; skip;}
        fi;
/* State DimmerValueSet */
DimmerValueSet:     atomic{skip; printf("in state Dimmer.DimmerValueSet\n");
        }

        DimmerValueSet_G:
        if
        :: atomic{Dimmer_q?changeDimmerValue -> 
                   Dimmer_changeDimmerValue_p1?Dimmer_V.deltaDimmerValue
                   -> 
           Dimmer_V.tempDimmerValue=Dimmer_V.dimmerValue+Dimmer_V.deltaDimmerValue;
           printf("Transition to Dimmer.TempValueReceived (evt:changeDimmerValue(deltaDimmerValue)/tempDimmerValue:=dimmerValue+deltaDimmerValue)");goto TempValueReceived; skip;}
        :: atomic{Dimmer_q?dimmerOK -> 
           ComputingComponent_q!ccOK;
           printf("Transition to Dimmer.Idle (evt:dimmerOK()^ComputingComponent.ccOK)");goto Idle; skip;}
        fi;
/* State Idle */
Idle:         atomic{skip; printf("in state Dimmer.Idle\n");
        }

        Idle_G:
        if
        :: atomic{Dimmer_q?dimmerOK -> 
           printf("Transition to Dimmer.Idle (evt:dimmerOK())");goto Idle; skip;}
        :: atomic{Dimmer_q?getOperationalState -> 
           printf("Transition to Dimmer.DetermineOS (evt:getOperationalState())");goto DetermineOS; skip;}
        :: atomic{Dimmer_q?changeDimmerValue -> 
                   Dimmer_changeDimmerValue_p1?Dimmer_V.deltaDimmerValue
                   -> 
           Dimmer_V.tempDimmerValue=Dimmer_V.dimmerValue+Dimmer_V.deltaDimmerValue;
           printf("Transition to Dimmer.TempValueReceived (evt:changeDimmerValue(deltaDimmerValue)/tempDimmerValue:=dimmerValue+deltaDimmerValue)");goto TempValueReceived; skip;}
        fi;
/* State TempValueReceived */
TempValueReceived:     atomic{skip; printf("in state Dimmer.TempValueReceived\n");
        }

        TempValueReceived_G:
        if
           :: atomic{Dimmer_V.tempDimmerValue>1000 ->
              Dimmer_V.dimmerValue=1000;
              printf("Transition to Dimmer.ValueProcessed ([tempDimmerValue>1000]/dimmerValue:=1000)");goto ValueProcessed; skip;}
           :: atomic{Dimmer_V.tempDimmerValue>=0 && Dimmer_V.tempDimmerValue<=1000 ->
              Dimmer_V.dimmerValue=Dimmer_V.tempDimmerValue;
              printf("Transition to Dimmer.ValueProcessed ([tempDimmerValue>=0 & tempDimmerValue<=1000]/dimmerValue:=tempDimmerValue)");goto ValueProcessed; skip;}
           :: atomic{Dimmer_V.tempDimmerValue<0 ->
              Dimmer_V.dimmerValue=0;
              printf("Transition to Dimmer.ValueProcessed ([tempDimmerValue<0]/dimmerValue:=0)");goto ValueProcessed; skip;}
        fi;
/* State ValueProcessed */
ValueProcessed:     atomic{skip; printf("in state Dimmer.ValueProcessed\n");
        }

        ValueProcessed_G:
        if
        :: atomic{1 -> 
           Environment_setDimmerValue_p1!Dimmer_V.dimmerValue; Environment_q!setDimmerValue;
           printf("Transition to Dimmer.DimmerValueSet (^Environment.setDimmerValue(dimmerValue))");goto DimmerValueSet; skip;}
        fi;
exit:      skip
}
active proctype Environment()
{
atomic{
mtype m;

/*Init state*/
        goto  Idle; skip;};
/* State BrightnessValueRequested */
BrightnessValueRequested:     atomic{skip; printf("in state Environment.BrightnessValueRequested\n");
        }

        BrightnessValueRequested_G:
        if
        :: atomic{1 -> 
           Environment_V.brightnessValue=1100;
           printf("Transition to Environment.BrightnessValueSelected (/brightnessValue:=1100)");goto BrightnessValueSelected; skip;}
        :: atomic{1 -> 
           Environment_V.brightnessValue=850;
           printf("Transition to Environment.BrightnessValueSelected (/brightnessValue:=850)");goto BrightnessValueSelected; skip;}
        :: atomic{1 -> 
           Environment_V.brightnessValue=0;
           printf("Transition to Environment.BrightnessValueSelected (/brightnessValue:=0)");goto BrightnessValueSelected; skip;}
        :: atomic{1 -> 
           Environment_V.brightnessValue=300;
           printf("Transition to Environment.BrightnessValueSelected (/brightnessValue:=300)");goto BrightnessValueSelected; skip;}
        fi;
/* State BrightnessValueSelected */
BrightnessValueSelected:     atomic{skip; printf("in state Environment.BrightnessValueSelected\n");
        }

        BrightnessValueSelected_G:
        if
        :: atomic{1 -> 
           Environment_V.totalBrightnessValue=Environment_V.brightnessValue+Environment_V.dimmerValue;
           printf("Transition to Environment.TotalValueComputed (/totalBrightnessValue:=brightnessValue+dimmerValue)");goto TotalValueComputed; skip;}
        fi;
/* State DimmerValueSet */
DimmerValueSet:     atomic{skip; printf("in state Environment.DimmerValueSet\n");
        }

        DimmerValueSet_G:
        if
        :: atomic{1 -> 
           Environment_V.totalBrightnessValue=Environment_V.brightnessValue+Environment_V.dimmerValue;
           Dimmer_q!dimmerOK;
           printf("Transition to Environment.Idle (/totalBrightnessValue:=brightnessValue+dimmerValue^Dimmer.dimmerOK)");goto Idle; skip;}
        fi;
/* State Idle */
Idle:         atomic{skip; printf("in state Environment.Idle\n");
        }

        Idle_G:
        if
        :: atomic{Environment_q?setDimmerValue -> 
                   Environment_setDimmerValue_p1?Environment_V.dimmerValue
                   -> 
           printf("Transition to Environment.DimmerValueSet (evt:setDimmerValue(dimmerValue))");goto DimmerValueSet; skip;}
        :: atomic{Environment_q?getMotionValue -> 
           printf("Transition to Environment.MotionValueRequested (evt:getMotionValue())");goto MotionValueRequested; skip;}
        :: atomic{Environment_q?getBrightnessValue -> 
           printf("Transition to Environment.BrightnessValueRequested (evt:getBrightnessValue())");goto BrightnessValueRequested; skip;}
        fi;
/* State MotionValueRequested */
MotionValueRequested:     atomic{skip; printf("in state Environment.MotionValueRequested\n");
        }

        MotionValueRequested_G:
        if
        :: atomic{1 -> 
           Environment_V.motionValue=1;
           printf("Transition to Environment.MotionValueSelected (/motionValue:=1)");goto MotionValueSelected; skip;}
        :: atomic{1 -> 
           Environment_V.motionValue=0;
           printf("Transition to Environment.MotionValueSelected (/motionValue:=0)");goto MotionValueSelected; skip;}
        fi;
/* State MotionValueSelected */
MotionValueSelected:     atomic{skip; printf("in state Environment.MotionValueSelected\n");
        }

        MotionValueSelected_G:
        if
        :: atomic{1 -> 
           MotionSensor_setMotionValue_p1!Environment_V.motionValue; MotionSensor_q!setMotionValue;
           printf("Transition to Environment.Idle (^MotionSensor.setMotionValue(motionValue))");goto Idle; skip;}
        fi;
/* State TotalValueComputed */
TotalValueComputed:     atomic{skip; printf("in state Environment.TotalValueComputed\n");
        }

        TotalValueComputed_G:
        if
        :: atomic{1 -> 
           BrightnessSensor_setBrightnessValue_p1!Environment_V.totalBrightnessValue; BrightnessSensor_q!setBrightnessValue;
           printf("Transition to Environment.Idle (^BrightnessSensor.setBrightnessValue(totalBrightnessValue))");goto Idle; skip;}
        fi;
exit:      skip
}
active proctype GlobalFaultHandler()
{
atomic{
mtype m;

/*Init state*/
        goto  NoFault; skip;};
/* State CorectionInitiated */
CorectionInitiated:     atomic{skip; printf("in state GlobalFaultHandler.CorectionInitiated\n");
        }
        if
        :: skip -> false
        fi;
/* State Fault */
Fault:        atomic{skip; printf("in state GlobalFaultHandler.Fault\n");
        }

        Fault_G:
        if
        :: atomic{1 -> 
           Corrector_q!correctFault;
           printf("Transition to GlobalFaultHandler.CorectionInitiated (^Corrector.correctFault)");goto CorectionInitiated; skip;}
        fi;
/* State NoFault */
NoFault:      atomic{skip; printf("in state GlobalFaultHandler.NoFault\n");
        }

        NoFault_G:
        if
        :: atomic{GlobalFaultHandler_q?faultOccurred -> 
           printf("Transition to GlobalFaultHandler.Fault (evt:faultOccurred())");goto Fault; skip;}
        fi;
exit:      skip
}
active proctype LocalFaultHandler()
{
atomic{
mtype m;

/*Init state*/
        goto  NoFault; skip;};
/* State Fault */
Fault:        atomic{skip; printf("in state LocalFaultHandler.Fault\n");
        }

        Fault_G:
        if
        :: atomic{1 -> 
           GlobalFaultHandler_q!faultOccurred;
           printf("Transition to LocalFaultHandler.FaultReported (^GlobalFaultHandler.faultOccurred)");goto FaultReported; skip;}
        fi;
/* State FaultReported */
FaultReported:     atomic{skip; printf("in state LocalFaultHandler.FaultReported\n");
        }
        if
        :: skip -> false
        fi;
/* State NoFault */
NoFault:      atomic{skip; printf("in state LocalFaultHandler.NoFault\n");
        }

        NoFault_G:
        if
        :: atomic{LocalFaultHandler_q?faultOccurred -> 
           printf("Transition to LocalFaultHandler.Fault (evt:faultOccurred())");goto Fault; skip;}
        fi;
exit:      skip
}
active proctype MotionSensor()
{
atomic{
mtype m;

/*Init state*/
        goto  Idle; skip;};
/* State DetermineOS */
DetermineOS:     atomic{skip; printf("in state MotionSensor.DetermineOS\n");
        }

        DetermineOS_G:
        if
        :: atomic{1 -> 
           MotionSensor_V.operationalState=1;
           ComputingComponent_q!ccOK;
           printf("Transition to MotionSensor.Idle (/operationalState:=1^ComputingComponent.ccOK)");goto Idle; skip;}
        :: atomic{1 -> 
           MotionSensor_V.operationalState=0;
           ComputingComponent_q!ccFAIL;
           printf("Transition to MotionSensor.Idle (/operationalState:=0^ComputingComponent.ccFAIL)");goto Idle; skip;}
        fi;
/* State Idle */
Idle:         atomic{skip; printf("in state MotionSensor.Idle\n");
        }

        Idle_G:
        if
        :: atomic{MotionSensor_q?getOperationalState -> 
           printf("Transition to MotionSensor.DetermineOS (evt:getOperationalState())");goto DetermineOS; skip;}
        :: atomic{MotionSensor_q?getMotionValue -> 
           Environment_q!getMotionValue;
           printf("Transition to MotionSensor.MotionValueRequested (evt:getMotionValue()^Environment.getMotionValue)");goto MotionValueRequested; skip;}
        fi;
/* State MotionValueMeasured */
MotionValueMeasured:     atomic{skip; printf("in state MotionSensor.MotionValueMeasured\n");
        }

        MotionValueMeasured_G:
        if
        :: atomic{1 -> 
           ComputingComponent_setMotionValue_p1!MotionSensor_V.motionValue; ComputingComponent_q!setMotionValue;
           printf("Transition to MotionSensor.Idle (^ComputingComponent.setMotionValue(motionValue))");goto Idle; skip;}
        fi;
/* State MotionValueRequested */
MotionValueRequested:     atomic{skip; printf("in state MotionSensor.MotionValueRequested\n");
        }

        MotionValueRequested_G:
        if
        :: atomic{MotionSensor_q?setMotionValue -> 
                   MotionSensor_setMotionValue_p1?MotionSensor_V.motionValue
                   -> 
           printf("Transition to MotionSensor.MotionValueMeasured (evt:setMotionValue(motionValue))");goto MotionValueMeasured; skip;}
        fi;
exit:      skip
}
active proctype UserInterface()
{
atomic{
mtype m;

/*Init state*/
        goto  Idle; skip;};
/* State DesiredValueRequested */
DesiredValueRequested:     atomic{skip; printf("in state UserInterface.DesiredValueRequested\n");
        }

        DesiredValueRequested_G:
        if
        :: atomic{1 -> 
           UserInterface_V.desiredBrightnessValue=1000;
           printf("Transition to UserInterface.State1 (/desiredBrightnessValue:=1000)");goto State1; skip;}
        :: atomic{1 -> 
           UserInterface_V.desiredBrightnessValue=500;
           printf("Transition to UserInterface.State1 (/desiredBrightnessValue:=500)");goto State1; skip;}
        :: atomic{1 -> 
           UserInterface_V.desiredBrightnessValue=0;
           printf("Transition to UserInterface.State1 (/desiredBrightnessValue:=0)");goto State1; skip;}
        fi;
/* State Idle */
Idle:         atomic{skip; printf("in state UserInterface.Idle\n");
        }

        Idle_G:
        if
        :: atomic{UserInterface_q?getManualMode -> 
           printf("Transition to UserInterface.State2 (evt:getManualMode())");goto State2; skip;}
        :: atomic{UserInterface_q?setWarningLevel -> 
                   UserInterface_setWarningLevel_p1?UserInterface_V.warningLevel
                   -> 
           printf("Transition to UserInterface.OperationalStatusSet (evt:setWarningLevel(warningLevel))");goto OperationalStatusSet; skip;}
        :: atomic{UserInterface_q?getDesiredBrightnessValue -> 
           printf("Transition to UserInterface.DesiredValueRequested (evt:getDesiredBrightnessValue())");goto DesiredValueRequested; skip;}
        fi;
/* State OperationalStatusSet */
OperationalStatusSet:     atomic{skip; printf("in state UserInterface.OperationalStatusSet\n");
        }

        OperationalStatusSet_G:
        if
        :: atomic{1 -> 
           ComputingComponent_q!ccOK;
           printf("Transition to UserInterface.Idle (^ComputingComponent.ccOK)");goto Idle; skip;}
        fi;
/* State State1 */
State1:       atomic{skip; printf("in state UserInterface.State1\n");
        }

        State1_G:
        if
        :: atomic{1 -> 
           ComputingComponent_setDesiredBrightnessValue_p1!UserInterface_V.desiredBrightnessValue; ComputingComponent_q!setDesiredBrightnessValue;
           printf("Transition to UserInterface.Idle (^ComputingComponent.setDesiredBrightnessValue(desiredBrightnessValue))");goto Idle; skip;}
        fi;
/* State State2 */
State2:       atomic{skip; printf("in state UserInterface.State2\n");
        }

        State2_G:
        if
        :: atomic{1 -> 
           UserInterface_V.manualMode=1;
           ComputingComponent_q!ccOK;
           printf("Transition to UserInterface.Idle (/manualMode:=1^ComputingComponent.ccOK)");goto Idle; skip;}
        :: atomic{1 -> 
           UserInterface_V.manualMode=0;
           ComputingComponent_q!ccFAIL;
           printf("Transition to UserInterface.Idle (/manualMode:=0^ComputingComponent.ccFAIL)");goto Idle; skip;}
        fi;
exit:      skip
}
active proctype _SYSTEMCLASS_()
{



exit:      skip
}
