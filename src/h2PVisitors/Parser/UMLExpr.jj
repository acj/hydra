/**
 * UMLExpr.jj
 * 
 * Hydra Expression parser
 *
 * This file describes a parser that processes the following expressions
 * on UML state transitions:
 *
 *  - Events
 *	- Guards
 *	- Actions
 */

options {
  //LOOKAHEAD=2;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  SANITY_CHECK = true;
//  FORCE_LA_CHECK = true;
  STATIC = false;
}

PARSER_BEGIN(UMLExpr)

package h2PVisitors.Parser;

import h2PNodes.*;
import h2PVisitors.*;
import java.io.*;
import h2PFoundation.*;

public class UMLExpr extends NodeUtilityClass {
  public String finalStr = "";
  protected aNode classRef;
  protected AcceptReturnType globalOutputs;
  protected PromelaInPredicateVisitor pinpv;
  protected Reader dataStream;
  protected String lhsHint = "";

  public UMLExpr(AcceptReturnType theGlobalOutputs, PromelaInPredicateVisitor THEpinpv) {
  	this(new StringReader("This is a test string"));
  	globalOutputs = theGlobalOutputs;
  	pinpv = THEpinpv;
  }

  public String Parse_Me (aNode theClassRef, String expression) {
  	 classRef = theClassRef;
  	 String retStr = "";
  	 dataStream = new StringReader (expression);
  	 ReInit(dataStream);
  	 try {
  	 	retStr = stmt();
  	 }  catch (ParseException pe) {
  	 	ClassNode thisClassRef = (ClassNode) searchUpForDest (classRef, "ClassNode");
  		String className = thisClassRef.getID();
        System.err.println("\nThe error occurred in class `" + className + "' while parsing this: \n    " + expression + "\n");
        if (pe.getMessage() != null) {
        	System.err.println(pe.getMessage());
        }
        System.exit(-1);
  	 }

  	 return retStr;
  }

  /**
   * Mangles instance variable names so that they reference the global typedef
   * that holds member variables and their values for each class.
   *
   * For example, the class Foo will have a typedef called Foo_T and a default
   * instance named Foo_V.
   *
   * The "lhsHint" parameter provides a suggestion for the containing type when
   * the variable is of an enumerated type.  The suggestion is the name of the
   * variable being assigned to, compared with, and so on.  In the assignment
   * statement "InstanceVar FooType fooVar := OFF", the suggestion would be
   * "FooType".  This helps the parser to resolve "OFF" to "FooType.OFF".
   */
  public String InstVar (String nameToCheck) throws ParseException {
  	String className;
  	String varName = nameToCheck;
  	if (varName.contains(".")) {
  		int dotPos = varName.indexOf(".");
  		className = varName.substring(0, dotPos);
  		varName = varName.substring(dotPos+1);
  	} else {
  		ClassNode thisClassRef = (ClassNode) searchUpForDest (classRef, "ClassNode");
  		className = thisClassRef.getID();
  	}
  	
  	// At this point, the class name and attribute/identifier name are broken
  	// into two parts: className and varName
  	
  	// Determine whether this is a timer variable
  	String temp = className + "_V.";
  	String entities [] = globalOutputs.getStrSplit("TimerList");
  	for (int i = 0; i < entities.length; i++) {
  		if (entities[i].equals(varName)) {
  			temp = "Timer_V.";
  		}
  	}

	// First, check the class name.  There are three cases here:
	//
	// (1) The class name refers to a real class.
	// (2) The class name refers to an *instance* of a class that is stored
	//     as an attribute in another class.
	// (3) The class name refers to an enumerated type.
	if (!SymbolTable.symbolExists(className, Symbol.SymbolType.CLASS)) {
  		// The class name does not refer to a valid class.  Is it an attribute?
  		ClassNode thisClassRef = (ClassNode) searchUpForDest (classRef, "ClassNode");
  		String containingClassName = thisClassRef.getID();
  		String instanceName = className;
  		if (!SymbolTable.symbolExistsInClass(instanceName, containingClassName) &&
  			!SymbolTable.symbolExistsInEnum(varName, className)) {
	  		System.err.println("Error: class `" + className + "' " +
	  			"does not exist and class `" + containingClassName +
	  			"' has no member named `" + instanceName + "'."); 
	  		throw new ParseException();
	  	}
  	}

	// Next, work out how to format/mangle the name.
  	
  	// Is the variable name a valid attribute for the class?
	//
	// There are two cases here:
	// (1) The class name refers to a real class.
	// (2) The class name is an *instance* of a class.  In this case, we need
	//     to dereference the instance to find its class type.
	
	// Case (1)
	if (SymbolTable.symbolExistsInClass(varName, className)) {
		return temp + varName;
	} else { // Case (2)
		ClassNode thisClassRef = (ClassNode) searchUpForDest (classRef, "ClassNode");
	  	String containingClassName = thisClassRef.getID();
	  	String instName = className;
	  	if (SymbolTable.symbolExistsInClass(instName, containingClassName)) {
		  	Symbol instanceTypeSym = SymbolTable.getSymbol(
		  		instName, containingClassName, Symbol.SymbolType.INSTVAR);
		  	String instClass = instanceTypeSym.getDataType();
		  	if (SymbolTable.symbolExistsInClass(varName, instClass)) {
		  		// TODO: This is a very poor solution because it stuffs
		  		// references to every instance of a given class into
		  		// a singleton instance of that class.  We need to handle
		  		// multiple class instances properly.
		  		return instClass + "_V." + varName;
		  	} else {
		  		System.err.println("Error: class `" + instClass +
		  			"' (the class type of member `" + instName +
		  			"' in class `" + containingClassName +
		  			"') has no member named `" + varName + "'.");
		  		throw new ParseException(); 
		  	}
		}
	}
	
  	// Is the variable an enumerated type? 
  	if (SymbolTable.symbolExistsInEnum(varName, className)) {
  		return className + "__" + varName;
  	}
	
  	// Check whether the variable is an enumerated type
  	if (!lhsHint.equals("")) {
  		// In case the LHS is also a (previously-mangled) enumerated type
  		lhsHint = lhsHint.replace("__", ".");
  		
  		String hintOwningClass = "";
  		String hintAttrib = "";
  		if (lhsHint.contains(".")) {
	  		int dotPos = lhsHint.indexOf(".");
	  		hintOwningClass = lhsHint.substring(0, dotPos);
	  		if (hintOwningClass.contains("_V")) {
	  			hintOwningClass = hintOwningClass.substring(0, hintOwningClass.length() - 2);
	  		}
	  		hintAttrib = lhsHint.substring(dotPos + 1);
	  	} else {
	  		hintOwningClass = className;
	  		hintAttrib = lhsHint;
	  	}
	  	
	  	// Clear the lhsHint
	  	lhsHint = "";
	  	
	  	// If this enumerated type is fully resolved, then just check it
	  	// for validity and replace the '.' with our '__' separator
	  	if (!className.equals("") &&
	  		SymbolTable.symbolExistsInEnum(varName, className)) {
	  		
	  		return className + "__" + varName;
	  	}
		
	  	// Otherwise, try to determine the type of the variable on the left-hand side
	  	//
	  	// For example, in the assignment "doorStatus = AJAR", we need to
	  	// determine the type of doorStatus in order to resolve the type of
	  	// AJAR appropriately.
	 	if (SymbolTable.symbolExistsInClass(hintAttrib, hintOwningClass)) {
	 	 	Symbol s = SymbolTable.getSymbol(hintAttrib, hintOwningClass, Symbol.SymbolType.INSTVAR);
	 		String hintType = s.getDataType();
	 		if (!SymbolTable.symbolExistsInEnum(varName, hintType)) {
	 			System.err.println("Error: no value `" + varName + "' exists in enumerated type `" + hintType + "'");
	 			throw new ParseException();
  			} else {
  				return hintType + "__" + varName;
  			}
  		}
  	}
  	
  	// Search for a class in which this variable is defined.
  	String hintClass = SymbolTable.searchForSymbol(varName);
  	if (!hintClass.equals("")) {
  		// The symbol *is* defined, but not in this class. Give a hint.
  		System.err.println("Error: class `" + className +
  			"' has no member named `" + varName + "'.  " +
  			"Did you mean " + hintClass + "." + varName + "?"); 
  		throw new ParseException();
  	}
  	
  	return varName;
  }

  public String INPredicate(String predtarg) {
   	ClassNode thisClassRef = (ClassNode) searchUpForDest (classRef, "ClassNode");
   	String className = thisClassRef.getID();
   	aNode myParent = classRef.getParent().getParent().getParent();
   	String parentName = myParent.getID();
   	
   	/* TODO implement:
   	if (!Yacc->LkupSym($target)) 
        {
            die "In class $classname, $myparent->{object} $parentname, state $target undefined in IN predicate."
    }
   	*/
   	ClassBodyNode thisClassBodyRef = (ClassBodyNode) searchUpForDest (classRef, "ClassBodyNode");
   	pinpv.INTarget(thisClassBodyRef, predtarg);
   	
  	return className + "INPredicate_V.st_" + predtarg;
  }

  public String Assignment(String assignto, String assignfrom) throws ParseException {
  	String newleft = InstVar(assignto);
  	return newleft + "=" + assignfrom + ";";
  }
}

PARSER_END(UMLExpr)

SKIP:
{
 	" "
|	"\r"
|	"\t"
|  	"\n"
|  	"\f"
}

TOKEN:
{
   <OR: "||" | "|">
|  <AND: "&&" | "&">
|  <NOT: "~" | "!">
|  <IMP: "->">
|  <COMPARE_OP: ">=" | "<=" | ">" | "<" >
|  <EQUALITY_OP: "==" | "!=" | "<>"> 
|  <ASSGNOP: ":=" | "=">
|  <IN: "in">
|  <WHEN: "when">
|  <SENT: "sent">

|  <PLUS: "+">
|  <MINUS: "-">
|  <TIMES: "*">
|  <SEMICOLON: ";">
|  <LPARENS: "(">
|  <RPARENS: ")">
|  <PERIOD: ".">
|  <COMMA: ",">
|  <SLASH: "/">
|  <LBRACKET: "[">
|  <RBRACKET: "]">


|  < #CONSTANT: ( <DIGIT> )+ >
|  < #DIGIT: ["0" - "9"] >
|  < #LETTER: ["A"-"Z"] | ["a"-"z"] >
|  <NUM: <CONSTANT> >
|  <TRUTH: "true" | "TRUE" | "false" | "FALSE">
|  <ID: (<LETTER> | "_")(<LETTER> | "_" | <DIGIT>)*  >
|  <FULLID: <ID> <PERIOD> <ID>>

|  <UNOP: <NOT> | "<>" | "[]" >
|  <EQV: "<->">
}

String stmt() throws ParseException:
{}
{
  (
  	LOOKAHEAD(2)
    finalStr = assignment()
    |
    	finalStr = guard()
    |
    	finalStr = parameterList()
    |
    	finalStr = whenclause()
  )
  {
  	  return finalStr;
  }
}

String assignment() throws ParseException:
{
	Token t;
	String temp1, temp2;
}
{
	(
		t = <ID> { temp1 = t.image; lhsHint = t.image; }
	|
		t = <FULLID> { temp1 = t.image; lhsHint = t.image; }
	)
	<ASSGNOP>
	temp2 = expression()
	{ return Assignment(temp1, temp2); }
}

String function() throws ParseException:
{
	Token t;
	String funcID = "";
	String parameterListStr = "";
}
{
	(
		(
			t = <ID> { funcID = InstVar(t.image); }
		|
			t = <FULLID> { funcID = InstVar(t.image); }
		)
		<LPARENS>
		( parameterListStr = parameterList() )?
		<RPARENS>
	)
	{
		String cleanFuncID = funcID.replace("_V.", ".");
		int dotPos = cleanFuncID.indexOf(".");
		String className = cleanFuncID.substring(0, dotPos);
  		String attribName = cleanFuncID.substring(dotPos + 1);
		if (!SymbolTable.checkSymbolType(attribName, className, Symbol.SymbolType.SIGNAL)) {
			System.err.println("Error: " + attribName + " being called as an " +
				"operation.  Should this be an attribute reference?");
			throw new ParseException();
		} else {
			return (funcID + "(" + parameterListStr + ")");
		}
	}
|	(
		<IN>
		<LPARENS>
		(
			t = <ID> { funcID = InstVar(t.image); }
		|	t = <FULLID> { funcID = InstVar(t.image); }
		)
		<RPARENS>
	)
	{ return INPredicate(funcID); }
}

String parameterList() throws ParseException:
{
	String retVal = "";
	String temp = "";
}
{
	temp = parm() { retVal += temp; }
	(
		<COMMA>
		temp = parm() { retVal += temp; }
	)*
	{ return retVal; }
}

String parm() throws ParseException:
{
	Token t;
	String temp;
}
{
	temp = expression() { return temp; }
}

String guard() throws ParseException:
{
  String retVal = "";
  Token t;
}
{
	<LBRACKET>
	retVal = expression()
	<RBRACKET>
	{
		lhsHint = "";
		return retVal;
	}
}


String whenclause() throws ParseException:
{
	String retVal = "";
}
{
	<WHEN>
	<LPARENS>
	retVal = expression()
	<RPARENS>
	{ return retVal; }
}

String expression() throws ParseException:
{
	String retVal = "";
}
{
	retVal = logicalExpression()
	{ return retVal; }
}

String logicalExpression() throws ParseException:
{
	String retVal = "";
	String temp = "";
}
{
	retVal = booleanExpression()
	(
		<OR>
		temp = booleanExpression() { retVal = retVal + "||" + temp; }
	)*
	{ return retVal; }
}

String booleanExpression() throws ParseException:
{
	String retVal = "";
	String temp = "";
}
{
	retVal = equalityExpression()
	(
		<AND>
		temp = equalityExpression() { retVal = retVal + "&&" + temp; }
	)*
	{ return retVal; }
}

String equalityExpression() throws ParseException:
{
	Token t;
	String temp1 = "";
	String temp2 = "";
	String temp3 = "";
}
{
	temp1 = relationalExpression() { lhsHint = temp1; }
	(
		t = <EQUALITY_OP> { temp2 = t.image.replace("<>", "!="); }
		temp3 = relationalExpression()
	)*
	{ return temp1 + temp2 + temp3; }
}

String relationalExpression() throws ParseException:
{
	Token t;
	String temp1 = "";
	String temp2 = "";
	String temp3 = "";
}
{
	temp1 = additiveExpression()
	(
		t = <COMPARE_OP> { temp2 = t.image; }
		temp3 = additiveExpression()
	)*
	{ return temp1 + temp2 + temp3; }
}

String additiveExpression() throws ParseException:
{
	Token t;
	String temp1 = "";
	String temp2 = "";
	String temp3 = "";
}
{
	temp1 = multiplicativeExpression()
	(
		(
			t = <PLUS> { temp2 = t.image; }
		|
			t = <MINUS> { temp2 = t.image; }
		)
		temp3 = multiplicativeExpression()
	)*
	{ return temp1 + temp2 + temp3; }
}

String multiplicativeExpression() throws ParseException:
{
	Token t;
	String temp1 = "";
	String temp2 = "";
	String temp3 = "";
}
{
	temp1 = unaryExpression()
	(
		(
			t = <TIMES> { temp2 = t.image; }
		|
			t = <SLASH> { temp2 = t.image; }
		)
		temp3 = unaryExpression()
	)*
	{ return temp1 + temp2 + temp3; }
}

String unaryExpression() throws ParseException:
{
	Token t;
	String temp = "";
}
{
	(
		temp = primaryExpression() { return temp; }
	|
		<NOT>
		temp = primaryExpression() { return "!" + temp; }
	|
		<MINUS>
		temp = primaryExpression()  { return "-" + temp; }
	)
}

String primaryExpression() throws ParseException:
{
	Token t;
	String temp = "";
}
{
	(
		<LPARENS>
		temp = logicalExpression()
		<RPARENS>
	|
		LOOKAHEAD(2)
		temp = function()
	|
		t = <TRUTH> 
		{
			if (t.image.toUpperCase().equals("TRUE")) {
				return "1";
			} else {
				return "0";
			}
		}
	|
		temp = numid()
	)
	{ return temp; }
}

String numid() throws ParseException:
{
	Token t;
	String temp = "";
	boolean isnot = false;
}
{
	(
		t = <ID> { return InstVar(t.image); }
	|
		t = <FULLID> { return InstVar(t.image); }
	|
		t = <NUM> { return t.image; }
	)
}

