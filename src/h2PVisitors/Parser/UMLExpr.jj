/**
 *  UMLExpr.jj
 * UML/Hydra LTL parser
 */

options {
  LOOKAHEAD=2;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  SANITY_CHECK = true;
//  FORCE_LA_CHECK = true;
  STATIC = false;
}

PARSER_BEGIN(UMLExpr1)

package h2PVisitors.Parser;

import h2PNodes.*;
import h2PVisitors.*;
import java.io.*;
import h2PFoundation.*;

public class UMLExpr1 extends NodeUtilityClass {
  public String finalStr = "";
  protected aNode classRef;
  protected AcceptReturnType globalOutputs;
  protected PromelaInPredicateVisitor pinpv;
  protected Reader dataStream;
/*  
  public UMLExpr1(AcceptReturnType theGlobalOutputs) {
  	globalOutputs = theGlobalOutputs;
  }
*/

  public UMLExpr1(AcceptReturnType theGlobalOutputs, PromelaInPredicateVisitor THEpinpv) {
  	this(new StringReader("This is a test string"));
  	globalOutputs = theGlobalOutputs;
  	pinpv = THEpinpv;
  }

  // TODO work it! work it good...
  public String Parse_Me (aNode theClassRef, String expression) /*throws ParseException*/ {
  	 classRef = theClassRef;
  	 String retStr;
  	 dataStream = new StringReader (expression);
  	 ReInit(dataStream);
  	 try {
  	 	retStr = stmt();
  	 }  catch (ParseException pe) {
  	 	retStr = "*ERROR*";

        System.err.println("------------------------------------------------");
        System.err.println("Error parsing \"" + expression + "\"\n");
        System.err.println(pe.toString());
  	 }

  	 return retStr;
  }
  
  public String Compare(String arg1, String op, String arg2) {
  	if (op.equals("=")) {
  		return arg1 + "==" + arg2;
  	}
  	
  	return arg1 + op + arg2;
  }

  public String InstVar (String varname) {
  	ClassNode thisClassRef = (ClassNode) searchUpForDest (classRef, "ClassNode");
  	aNode returnValue = FindLocalDestNode (classRef, "InstanceVariableNode", "var", varname);
  	
  	String temp = thisClassRef.getID() + "_V.";
  	
  	String entities [] = globalOutputs.getStrSplit("TimerList");
  	for (int i = 0; i < entities.length; i++) {
  		if (entities[i].equals(varname)) {
  			temp = "Timer_V.";
  		}
  	}
  	if (returnValue != null) {
  		return temp + varname;
  	}
  	return varname;
  }

  public String Logic(String op, String arg1) {
  	return Logic (op, arg1, "");
  }

  public String Logic(String op, String arg1, String arg2) {
  	if ((op.equals ("not")) && (arg2.length() == 0)) {
  		return "!" + InstVar (arg1);
  	}
  	if (op.equals ("or")) {
  		return arg1 + " || " + arg2;
  	}
  	if (op.equals ("and")) {
  		return arg1 + " && " + arg2;
  	}
  	
  	//T O D O  $ret || die "Logic was passed a bad operator: <$op>";
  	println ("Logic was passed a bad operator: <" + op + ">");
  	exit();
  	return "";
  }

  public String INPredicate(String predtarg) {
   	ClassNode thisClassRef = (ClassNode) searchUpForDest (classRef, "ClassNode");
   	String className = thisClassRef.getID();
   	aNode myParent = classRef.getParent().getParent().getParent();
   	String parentName = myParent.getID();
   	
   	/* TODO implement:
   	if (!Yacc->LkupSym($target)) 
        {
            die "In class $classname, $myparent->{object} $parentname, state $target undefined in IN predicate."
    }
   	*/
   	ClassBodyNode thisClassBodyRef = (ClassBodyNode) searchUpForDest (classRef, "ClassBodyNode");
   	pinpv.INTarget(thisClassBodyRef, predtarg);
   	
  	return className + "INPredicate_V.st_" + predtarg;
  }

  public String Assignment(String assignto, String assignfrom) {
  	String newleft = InstVar(assignto);
  	return newleft + "=" + assignfrom + ";";
  }
}

PARSER_END(UMLExpr1)

SKIP:
{
 	" "
|	"\r"
|	"\t"
|  	"\n"
|  	"\f"
}

TOKEN:
{
   <OR: "|">
|  <AND: "&">
|  <NOT: "~">
|  <IMP: "->">
|  <COMPARE_OP: "=" | "!=" | ">=" | "<=" | ">" | "<" > 
|  <ASSGNOP: ":=">
|  <IN: "in">
|  <WHEN: "when">
|  <SENT: "sent">

|  <PLUS: "+">
|  <MINUS: "-">
|  <TIMES: "*">
|  <SEMICOLON: ";">
|  <LPARENS: "(">
|  <RPARENS: ")">
|  <PERIOD: ".">
|  <COMMA: ",">
|  <SLASH: "/">
|	<LBRACKET: "[">
|	<RBRACKET: "]">


|	< #CONSTANT: ( <DIGIT> )+ >
|   < #DIGIT: ["0" - "9"] >
|   < #LETTER: ["A"-"Z"] | ["a"-"z"] >
|  <NUM: <CONSTANT> >
|  <ID: (<LETTER> | "_")(<LETTER> | "_" | <DIGIT>)*  >

|  <UNOP: <NOT> | "<>" | "[]" >
|  <EQV: "<->">
}

String stmt() throws ParseException:
{}
{
  (
      finalStr = assignment()
    | finalStr = guard()
    | finalStr = parmlist()
    | finalStr = whenclause()
  )
  { 
    return finalStr;
  }
}

String assignment() throws ParseException:
{
	Token t;
	String temp1, temp2;
}
{
	t = <ID> { temp1 = t.image; }
	<ASSGNOP>
	temp2 = stmtpm()
	{ return Assignment(temp1, temp2); }
}

String stmtpm() throws ParseException:
{
	Token t;
	String retVal = "";
	String temp;
}
{ // double check what it does!
	(
	  temp = stmtdm() { retVal += temp; }
	  (
	    ( 
	        t = <PLUS>
	      | t = <MINUS>
	    ) { retVal += t.image; }
	    temp = stmtdm() {retVal += temp;}
	  )*
	) { return retVal; }
}

String stmtdm() throws ParseException:
{
	Token t;
	String retVal = "";
	String temp;
}
{ // double check what it does!
	(
	  temp = actterm() { retVal += temp; }
	  (
	    ( 
	        t = <TIMES>
	      | t = <SLASH>
	    ) { retVal += t.image; }
	    temp = actterm() {retVal += temp;}
	  )*
	) { return retVal; }
}

String actterm() throws ParseException:
{
	Token t;
	String retVal = "";
	String temp;
	boolean isID = false;
}
{
	retVal = function() { return retVal; }
|	(
		( <MINUS> { retVal += "-"; } )? 
		(
		  t = <ID> { isID = true; }
		| t = <NUM>
		) { temp = t.image; }
	)
	{
		if (isID) {
		  temp = InstVar(temp);
		} 
		return (retVal + temp); }
|	(
		<LPARENS>
		retVal = stmtpm()
		<RPARENS>
	) { return ("(" + retVal + ")"); }
}

String function() throws ParseException:
{
	Token t;
	String funcID = "";
	String parmlistStr = "";
}
{
	(
		t = <ID> { funcID = t.image; }
		<LPARENS>
		parmlistStr = parmlist()
		<RPARENS>
	)
	{ return (funcID + "(" + parmlistStr + ")"); }
|	(
		<IN>
		<LPARENS>
		t = <ID> { funcID = t.image; }
		<RPARENS>
	)
	{ return INPredicate(funcID); }
}


String parmlist() throws ParseException:
{
	String retVal = "";
	String temp = "";
}
{
	temp = parm() { retVal += temp; }
	(
		<COMMA>
		temp = parm() { retVal += temp; }
	)*
	{ return retVal; }
}

String parm() throws ParseException:
{
	Token t;
	String temp;
}
{
	t = <ID> { return InstVar(t.image); }
|	t = <NUM> { return t.image; }
|	temp = pred() { return temp; }
}

String guard() throws ParseException:
{
  String retVal = "";
}
{
  <LBRACKET> retVal = guardbody() <RBRACKET>
  { return retVal; }
}

String guardbody() throws ParseException:
{
	String retVal = "";
	String temp = "";
}
{
	retVal = expra()
	( 
	  <OR>
	  temp = expra() { retVal = Logic("or", retVal, temp); }
	)*
	{ return retVal; }
}

String expra() throws ParseException:
{
	String retVal = "";
	String temp = "";
}
{
	retVal = gdterm()
	(
	  <AND>
	  temp = gdterm() { retVal = Logic("and", retVal, temp); }
	)*
	{ return retVal; }
}

String gdterm() throws ParseException:
{
	Token t;
	String retVal = "";
	String temp;
	boolean isnot = false;
}
{
	retVal = pred()
	{ return retVal; }
/*|	(
	  t = <ID>  { temp = t.image; }
	)
	{ return InstVar(temp); } */
|	(
  	  ( <NOT> { isnot = true;} )?
	  t = <ID>  { temp = t.image; }
	)
	{ 
		if (isnot) {
			return Logic("not", temp); 
		} else {
			return  InstVar(temp); 
		}
	} 
|	(
	  <LPARENS>
	  retVal = guardbody()
	  <RPARENS>
	)
	{  return ("(" + retVal + ")"); }
}

String pred() throws ParseException:
{
	Token t;
	String retVal = "";
	String temp1, temp2, temp3;
}
{
	(
		temp1 = numid()
		t = <COMPARE_OP> { temp2 = t.image; }
		temp3 = numid()
	)  { return Compare(temp1, temp2, temp3); }
|	retVal = function() { return retVal; }
}

String numid() throws ParseException:
{
	Token t;
}
{
	t = <ID> { return InstVar (t.image); }
|	t = <NUM> { return t.image; }
}

String whenclause() throws ParseException:
{
	String retVal = "";
}
{
	<WHEN>
	<LPARENS>
	retVal = guardbody()
	<RPARENS>
	{ return retVal; }
}

