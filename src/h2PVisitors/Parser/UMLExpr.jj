/**
 * UMLExpr.jj
 * 
 * Hydra Expression parser
 *
 * This file describes a parser that processes the following expressions
 * on UML state transitions:
 *
 *  - Events
 *	- Guards
 *	- Actions
 */

options {
  //LOOKAHEAD=2;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  SANITY_CHECK = true;
//  FORCE_LA_CHECK = true;
  STATIC = false;
}

PARSER_BEGIN(UMLExpr)

package h2PVisitors.Parser;

import h2PNodes.*;
import h2PVisitors.*;
import java.io.*;
import h2PFoundation.*;

public class UMLExpr extends NodeUtilityClass {
  public String finalStr = "";
  protected aNode classRef;
  protected AcceptReturnType globalOutputs;
  protected PromelaInPredicateVisitor pinpv;
  protected Reader dataStream;
  protected String lhsHint = "";

  public UMLExpr(AcceptReturnType theGlobalOutputs, PromelaInPredicateVisitor THEpinpv) {
  	this(new StringReader("This is a test string"));
  	globalOutputs = theGlobalOutputs;
  	pinpv = THEpinpv;
  }

  public String Parse_Me (aNode theClassRef, String expression) {
  	 classRef = theClassRef;
  	 String retStr;
  	 dataStream = new StringReader (expression);
  	 ReInit(dataStream);
  	 try {
  	 	retStr = stmt();
  	 }  catch (ParseException pe) {
  	 	retStr = "*ERROR*";

        System.err.println("------------------------------------------------");
        System.err.println("Error parsing \"" + expression + "\"\n");
        //System.err.println(pe.toString());
        pe.printStackTrace();
        
        System.exit(-1);
  	 }

  	 return retStr;
  }

  /**
   * Mangles instance variable names so that they reference the global typedef
   * that holds member variables and their values for each class.
   *
   * For example, the class Foo will have a typedef called Foo_T and a default
   * instance named Foo_V.
   *
   * The "lhsHint" parameter provides a suggestion for the containing type when
   * the variable is of an enumerated type.  The suggestion is the name of the
   * variable being assigned to, compared with, and so on.  In the assignment
   * statement "InstanceVar FooType fooVar := OFF", the suggestion would be
   * "FooType".  This helps the parser to resolve "OFF" to "FooType.OFF".
   */
  public String InstVar (String varname) throws ParseException {
  	String className;
  	if (varname.contains(".")) {
  		int dotPos = varname.indexOf(".");
  		className = varname.substring(0, dotPos);
  		varname = varname.substring(dotPos+1);
  	} else {
  		ClassNode thisClassRef = (ClassNode) searchUpForDest (classRef, "ClassNode");
  		className = thisClassRef.getID();
  	}
  	
  	String temp = className + "_V.";
  	// Determine whether this is a timer variable
  	String entities [] = globalOutputs.getStrSplit("TimerList");
  	for (int i = 0; i < entities.length; i++) {
  		if (entities[i].equals(varname)) {
  			temp = "Timer_V.";
  		}
  	}
  	
  	// Does the variable exist within the class?
  	if (SymbolTable.symbolExistsInClass(varname, className)) {
  		return temp + varname;
  	}
  	
  	// Check whether the variable is an enumerated type
  	if (!lhsHint.equals("")) {
  		// In case the LHS is also a (previously-mangled enumerated type
  		lhsHint = lhsHint.replace("__", ".");
  		
  		String hintOwningClass = "";
  		String hintAttrib = "";
  		if (lhsHint.contains(".")) {
	  		int dotPos = lhsHint.indexOf(".");
	  		hintOwningClass = lhsHint.substring(0, dotPos);
	  		if (hintOwningClass.contains("_V")) {
	  			hintOwningClass = hintOwningClass.substring(0, hintOwningClass.length() - 2);
	  		}
	  		hintAttrib = lhsHint.substring(dotPos + 1);
	  	} else {
	  		hintOwningClass = className;
	  		hintAttrib = lhsHint;
	  	}
	  	
	  	// Clear the lhsHint
	  	lhsHint = "";
	  	
	  	// If this enumerated type is fully resolved, then just check it
	  	// for validity and replace the '.' with our '__' separator
	  	if (!className.equals("") &&
	  		SymbolTable.symbolExistsInEnum(varname, className)) {
	  		
	  		return className + "__" + varname;
	  	}
	  	// Try to determine the type of the variable being assigned to
	 	if (SymbolTable.symbolExistsInClass(hintAttrib, hintOwningClass)) {
	 	 	Symbol s = SymbolTable.getSymbol(hintAttrib, hintOwningClass, Symbol.SymbolType.INSTVAR);
	 		String hintType = s.getDataType();
	 		if (!SymbolTable.symbolExistsInEnum(varname, hintType)) {
	 			System.err.println("Error: no value `" + varname + "' exists in enumerated type `" + hintType + "'");
	 			throw new ParseException();
  			} else {
  				return hintType + "__" + varname;
  			}
  		}
  	}
  	
  	// Search for a class in which this variable is defined.
  	String hintClass = SymbolTable.searchForSymbol(varname);
  	if (hintClass != "") {
  		// The symbol *is* defined, but not in this class. Give a hint.
  		System.err.println("Error: reference to undefined variable `" +
  			varname + "' in class `" + className + "'.  " +
  			"Did you mean " + hintClass + "." + varname + "?"); 
  		throw new ParseException();
  	}
  	
  	// Finally, check the class name itself
  	if (!SymbolTable.symbolExists(className, Symbol.SymbolType.CLASS)) {
  		System.err.println("Error: reference to undefined class `" +
  			className + "'."); 
  		throw new ParseException();
  	}
  	
  	return varname;
  }

  public String INPredicate(String predtarg) {
   	ClassNode thisClassRef = (ClassNode) searchUpForDest (classRef, "ClassNode");
   	String className = thisClassRef.getID();
   	aNode myParent = classRef.getParent().getParent().getParent();
   	String parentName = myParent.getID();
   	
   	/* TODO implement:
   	if (!Yacc->LkupSym($target)) 
        {
            die "In class $classname, $myparent->{object} $parentname, state $target undefined in IN predicate."
    }
   	*/
   	ClassBodyNode thisClassBodyRef = (ClassBodyNode) searchUpForDest (classRef, "ClassBodyNode");
   	pinpv.INTarget(thisClassBodyRef, predtarg);
   	
  	return className + "INPredicate_V.st_" + predtarg;
  }

  public String Assignment(String assignto, String assignfrom) throws ParseException {
  	String newleft = InstVar(assignto);
  	return newleft + "=" + assignfrom + ";";
  }
}

PARSER_END(UMLExpr)

SKIP:
{
 	" "
|	"\r"
|	"\t"
|  	"\n"
|  	"\f"
}

TOKEN:
{
   <OR: "||" | "|">
|  <AND: "&&" | "&">
|  <NOT: "~" | "!">
|  <IMP: "->">
|  <COMPARE_OP: ">=" | "<=" | ">" | "<" >
|  <EQUALITY_OP: "==" | "!=" | "<>"> 
|  <ASSGNOP: ":=" | "=">
|  <IN: "in">
|  <WHEN: "when">
|  <SENT: "sent">

|  <PLUS: "+">
|  <MINUS: "-">
|  <TIMES: "*">
|  <SEMICOLON: ";">
|  <LPARENS: "(">
|  <RPARENS: ")">
|  <PERIOD: ".">
|  <COMMA: ",">
|  <SLASH: "/">
|  <LBRACKET: "[">
|  <RBRACKET: "]">


|  < #CONSTANT: ( <DIGIT> )+ >
|  < #DIGIT: ["0" - "9"] >
|  < #LETTER: ["A"-"Z"] | ["a"-"z"] >
|  <NUM: <CONSTANT> >
|  <TRUTH: "true" | "TRUE" | "false" | "FALSE">
|  <ID: (<LETTER> | "_")(<LETTER> | "_" | <DIGIT>)*  >
|  <FULLID: <ID> <PERIOD> <ID>>

|  <UNOP: <NOT> | "<>" | "[]" >
|  <EQV: "<->">
}

String stmt() throws ParseException:
{}
{
  (
  	LOOKAHEAD(2)
    finalStr = assignment()
    |
    	finalStr = guard()
    |
    	finalStr = parameterList()
    |
    	finalStr = whenclause()
  )
  { 
    return finalStr;
  }
}

String assignment() throws ParseException:
{
	Token t;
	String temp1, temp2;
}
{
	(
		t = <ID> { temp1 = t.image; lhsHint = t.image; }
	|
		t = <FULLID> { temp1 = t.image; lhsHint = t.image; }
	)
	<ASSGNOP>
	temp2 = expression()
	{ return Assignment(temp1, temp2); }
}

String function() throws ParseException:
{
	Token t;
	String funcID = "";
	String parameterListStr = "";
}
{
	(
		(
			t = <ID> { funcID = InstVar(t.image); }
		|
			t = <FULLID> { funcID = InstVar(t.image); }
		)
		<LPARENS>
		( parameterListStr = parameterList() )?
		<RPARENS>
	)
	{ return (funcID + "(" + parameterListStr + ")"); }
|	(
		<IN>
		<LPARENS>
		(
			t = <ID> { funcID = InstVar(t.image); }
		|	t = <FULLID> { funcID = InstVar(t.image); }
		)
		<RPARENS>
	)
	{ return INPredicate(funcID); }
}

String parameterList() throws ParseException:
{
	String retVal = "";
	String temp = "";
}
{
	temp = parm() { retVal += temp; }
	(
		<COMMA>
		temp = parm() { retVal += temp; }
	)*
	{ return retVal; }
}

String parm() throws ParseException:
{
	Token t;
	String temp;
}
{
	temp = expression() { return temp; }
}

String guard() throws ParseException:
{
  String retVal = "";
  Token t;
}
{
	<LBRACKET>
	retVal = expression()
	<RBRACKET>
	{ return retVal; }
}


String whenclause() throws ParseException:
{
	String retVal = "";
}
{
	<WHEN>
	<LPARENS>
	retVal = expression()
	<RPARENS>
	{ return retVal; }
}

String expression() throws ParseException:
{
	String retVal = "";
}
{
	retVal = logicalExpression()
	{ return retVal; }
}

String logicalExpression() throws ParseException:
{
	String retVal = "";
	String temp = "";
}
{
	retVal = booleanExpression()
	(
		<OR>
		temp = booleanExpression() { retVal = retVal + "||" + temp; }
	)*
	{ return retVal; }
}

String booleanExpression() throws ParseException:
{
	String retVal = "";
	String temp = "";
}
{
	retVal = equalityExpression()
	(
		<AND>
		temp = equalityExpression() { retVal = retVal + "&&" + temp; }
	)*
	{ return retVal; }
}

String equalityExpression() throws ParseException:
{
	Token t;
	String temp1 = "";
	String temp2 = "";
	String temp3 = "";
}
{
	temp1 = relationalExpression() { lhsHint = temp1; }
	(
		t = <EQUALITY_OP> { temp2 = t.image.replace("<>", "!="); }
		temp3 = relationalExpression()
	)*
	{ return temp1 + temp2 + temp3; }
}

String relationalExpression() throws ParseException:
{
	Token t;
	String temp1 = "";
	String temp2 = "";
	String temp3 = "";
}
{
	temp1 = additiveExpression()
	(
		t = <COMPARE_OP> { temp2 = t.image; }
		temp3 = additiveExpression()
	)*
	{ return temp1 + temp2 + temp3; }
}

String additiveExpression() throws ParseException:
{
	Token t;
	String temp1 = "";
	String temp2 = "";
	String temp3 = "";
}
{
	temp1 = multiplicativeExpression()
	(
		(
			t = <PLUS> { temp2 = t.image; }
		|
			t = <MINUS> { temp2 = t.image; }
		)
		temp3 = multiplicativeExpression()
	)*
	{ return temp1 + temp2 + temp3; }
}

String multiplicativeExpression() throws ParseException:
{
	Token t;
	String temp1 = "";
	String temp2 = "";
	String temp3 = "";
}
{
	temp1 = unaryExpression()
	(
		(
			t = <TIMES> { temp2 = t.image; }
		|
			t = <SLASH> { temp2 = t.image; }
		)
		temp3 = unaryExpression()
	)*
	{ return temp1 + temp2 + temp3; }
}

String unaryExpression() throws ParseException:
{
	Token t;
	String temp = "";
}
{
	(
		temp = primaryExpression() { return temp; }
	|
		<NOT>
		temp = primaryExpression() { return "!" + temp; }
	|
		<MINUS>
		temp = primaryExpression()  { return "-" + temp; }
	)
}

String primaryExpression() throws ParseException:
{
	Token t;
	String temp = "";
}
{
	(
		<LPARENS>
		temp = logicalExpression()
		<RPARENS>
	|
		LOOKAHEAD(2)
		temp = function()
	|
		t = <TRUTH> 
		{
			if (t.image.toUpperCase().equals("TRUE")) {
				return "1";
			} else {
				return "0";
			}
		}
	|
		temp = numid()
	)
	{ return temp; }
}

String numid() throws ParseException:
{
	Token t;
	String temp = "";
	boolean isnot = false;
}
{
	(
		t = <ID> { return InstVar(t.image); }
	|
		t = <FULLID> { return InstVar(t.image); }
	|
		t = <NUM> { return t.image; }
	)
}

